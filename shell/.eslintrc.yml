---
env:
  # Assume standard globals. We turn off either `browser` or `node`
  # for certain parts of the codebase in `overrides`, but by default
  # we optimistically assume everything is available.
  #
  # TODO: More cleanly separate client vs. server code, and then
  # avoid having both of these on anywhere. Unfortunatley, there are
  # some places where we have both in the same file, hidden behind a
  # conditional.
  browser: true
  node: true

  shared-node-browser: true
  es6: true
parser: "@typescript-eslint/parser"
parserOptions:
  ecmaVersion: 2020
  sourceType: "module"

  # There are a few places where we do if(Meteor.isServer) { import ... }.
  # Ideally we'd refactor so this was unneccesary, but for now the import
  # *has* to be conditional, so tell eslint to allow this:
  allowImportExportEverywhere: true
overrides:
  - files:
      - "**/client/**/*.js"
      - "**/client/**/*.ts"
    env:
      node: false
  - files:
      - "**/server/**/*.js"
      - "**/server/**/*.ts"
    env:
      browser: false
  - files:
      - "**/shared/**/*.js"
      - "**/shared/**/*.ts"
    env:
      node: false
      browser: false
reportUnusedDisableDirectives: true
extends:
  - "eslint:recommended"
  - "plugin:@typescript-eslint/eslint-recommended"
  - "plugin:@typescript-eslint/recommended"
rules:
  # These are implied by one of the items in extends, but we haven't gotten
  # around to fixing them yet:
  no-undef: ["warn"]
  no-empty: ["warn"]
  no-inner-declarations: ["warn"]
  "@typescript-eslint/no-empty-function": ["warn"]
  "@typescript-eslint/no-unused-vars": ["warn", {"argsIgnorePattern": "^_"}]
  # superceeded by the type script version, which understands types:
  no-unused-vars: ["off"]
  # This flags assignemnts of this to another variable, which we do a lot,
  # e.g. `const this_ = this;`, to avoid worrying about dynamic scope.
  # I(zenhack) have no idea why someone decided this was something to lint
  # about. Turn it off:
  "@typescript-eslint/no-this-alias": ["off"]
  # This flags top level functions that don't have types on them, but it does
  # so even in .js files, where type syntax isn't supported anyway! We already
  # have noImplictAny in our typescript config, so this adds no real extra
  # value:
  "@typescript-eslint/explicit-module-boundary-types": ["off"]
